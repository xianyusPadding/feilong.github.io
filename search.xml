<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[chapter01---渲染并展示三维对象2]]></title>
    <url>%2F2017%2F06%2F26%2Fchapter01-%E6%B8%B2%E6%9F%93%E5%B9%B6%E5%B1%95%E7%A4%BA%E4%B8%89%E7%BB%B4%E5%AF%B9%E8%B1%A12%2F</url>
    <content type="text"><![CDATA[使用动画扩展场景引入requestAnimationFrame()方法 其实我们可以通过setInterval()方法指定函数每隔一个间隔调用一次函数，但是setInterval()方法并无法跟显示器的重画同步。这会导致较高的cpu使用率。所以这里我们使用requestAnimationFrame()方法取代setInterval()。1234567891011121314151617var step = 0;function renderScene() &#123; stats.update(); // 转动方块 cube.rotation.x += 0.02; cube.rotation.y += 0.02; cube.rotation.z += 0.02; // 弹跳小球 step += 0.04; sphere.position.x = 20 + ( 10 * (Math.cos(step))); sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step))); requestAnimationFrame(renderScene); renderer.render(scene, camera);&#125;$('#WebGL-output').append(renderer.domElement);renderScene() 这里我们可以使用一个小的辅助库stats.j，这也是Three.js的作者创建的，它的主要效果是可以在一个小图片显示每秒显示的帧数（FPS）。html:123&lt;script type="text/javascript" src="js/stats.js"&gt;&lt;/script&gt;&lt;div id="Stats-output"&gt;&lt;/div&gt; js:1234567891011var stats = initStats();function initStats() &#123; var stats = new Stats(); stats.setMode(0); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; $('#Stats-output').append(stats.domElement); return stats;&#125; 显示每秒帧数： 最后效果如下：]]></content>
      <categories>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>three.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter01:渲染并展示三维对象1]]></title>
    <url>%2F2017%2F06%2F26%2Fchapter01---%E6%B8%B2%E6%9F%93%E5%B9%B6%E5%B1%95%E7%A4%BA%E4%B8%89%E7%BB%B4%E5%AF%B9%E8%B1%A11%2F</url>
    <content type="text"><![CDATA[首先我们要做的效果具体如下： 那我们应该怎么去使用three.js来做出这种效果呢？ 现在我们要创建的一个场景scene,也就是我们日常说到的容器，添加几个物体和相机。 创建基本的页面框架123456789101112131415161718&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Example01-01&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/three.js"&gt;&lt;/script&gt; &lt;style&gt; body&#123;margin: 0;overflow: hidden;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="WebGL-output"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $(function () &#123; &#125;) &lt;/script&gt;&lt;/body&gt; 渲染并展示三维对象html:12&lt;div id="WebGL-output"&gt;&lt;/div&gt; js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script type="text/javascript"&gt; $(function () &#123; //scene场景 var scene = new THREE.Scene(); //camera var camera = new THREE.PerspectiveCamera(45, window.innerWidth/innerHeight, 0.1, 1000); //randerer var renderer = new THREE.WebGLRenderer(); //设置renderer的背景颜色：0xEEEEEE, 和尺寸 renderer.setClearColor(0xEEEEEE); renderer.setSize(window.innerWidth, window.innerHeight); //axes坐标轴 var axes = new THREE.AxisHelper(20); scene.add(axes); //定义平面的尺寸 var planeGeometry = new THREE.PlaneGeometry(60, 20); //创建基本材质 var planeMaterial = new THREE.MeshBasicMaterial(&#123; color: 0xcccccc &#125;) //plane平面 var plane = new THREE.Mesh(planeGeometry, planeMaterial); //围绕x轴旋转90deg plane.rotation.x = -0.5*Math.PI; //position定位 plane.position.x = 15; plane.position.y = 0; plane.position.z = 0; scene.add(plane); //cube方块 var cubeGeometry = new THREE.CubeGeometry(4, 4, 4); var cubeMaterial = new THREE.MeshBasicMaterial(&#123; color: 0xff0000, wireframe: true &#125;); var cube = new THREE.Mesh(cubeGeometry, cubeMaterial); cube.position.x = -4; cube.position.y = 3; cube.position.z = 0; scene.add(cube); //sphere球体 var sphereGeometry = new THREE.SphereGeometry(4, 20, 20); var sphereMaterial = new THREE.MeshBasicMaterial(&#123; color: 0x77ffff, wireframe: true &#125;); var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); sphere.position.x = 20; sphere.position.y = 4; sphere.position.z = 2; scene.add(sphere); camera.position.x = -30; camera.position.y = 40; camera.position.z = 30; camera.lookAt(scene.position); $('#WebGL-output').append(renderer.domElement); renderer.render(scene, camera); &#125;)&lt;/script&gt; 添加材质、灯光和阴影 在Three.js里添加新材质和灯光非常简单，做法和前面说道的一样。我们首先在场景里添加一个新的光源（在上一段的js添加） 123var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, -10);scene.add(spotLight); 通过SpotLight()方法创建一个光源，并从 spotLight.position.set(-40, 60, -10)的位置照射我们的场景 在前一段的js里，我们使用的是基础材质MeshBasicMaterial()，它不会对光源产生反应，只能以指定的颜色渲染物体，那么我们不得不改变plane、sphere和cube的材质了，这里使用的是MeshLamberMaterial() 渲染效果如下： 现在我们需要添加阴影。生成阴影很简单 12345renderer.shadowMapEnabled = true;renderer.shadowMapEnabled = true;plane.receiveShadow = true;sphere.castShadow = true;spotLight.castShadow = true; 再把小球和方块的网格线去掉 12var cubeMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xff0000&#125;);var sphereMaterial = new THREE.MeshBasicMaterial(&#123;color: 0x7777ff&#125;); 那就好了：]]></content>
      <categories>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>three.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈hexo部署个人blog]]></title>
    <url>%2F2017%2F06%2F25%2F%E6%B5%85%E8%B0%88hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BAblog%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>